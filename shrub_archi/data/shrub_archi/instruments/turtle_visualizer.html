<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turtle RDF Graph Visualizer</title>
    <!-- Load Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load D3.js for graph visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- CRUCIAAL: Laad de N3.js parser bibliotheek voor echte Turtle-ondersteuning -->
    <script src="https://cdn.jsdelivr.net/npm/n3@1.16.2/browser/n3.min.js"></script>
    <style>
        /* Define the container for the SVG graph */
        #graph-container {
            width: 100%;
            height: 50vh; /* Aangepast naar viewport hoogte voor meeschalen */
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            background-color: #f9fafb;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }

        /* Styling for graph elements */
        .link {
            stroke: #9ca3af;
            stroke-width: 3px;
            fill: none; /* Cruciaal voor curved links */
        }

        .node-circle {
            stroke: #fff;
            stroke-width: 1.5px;
            cursor: pointer;
        }

        .node-label, .link-label {
            pointer-events: none; /* Ignore mouse events on text */
            font-family: 'Inter', sans-serif;
            fill: #1f2937;
        }
    </style>
</head>
<body class="bg-gray-50 p-6 font-sans">

    <div class="w-full mx-auto">
        <h1 class="text-3xl font-extrabold text-indigo-800 mb-2">Turtle RDF Graph Visualizer</h1>
        <p class="text-gray-600 mb-6">Voer relaties in een vereenvoudigde Turtle-syntaxis in om een interactieve geforceerde grafiek te genereren.</p>

        <!-- Control and Input Area -->
        <div class="mb-6 bg-white p-4 rounded-lg shadow">

            <!-- Controls (Layout and Slider) -->
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-4 items-end">
                <!-- Layout Dropdown -->
                <div>
                    <label for="layoutSelect" class="block text-sm font-medium text-gray-700 mb-1">Layout Optie</label>
                    <select id="layoutSelect" onchange="toggleLayoutControls()" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                        <option value="force">Force Directed (Zwaartekracht)</option>
                        <option value="hierarchical">Hiërarchisch (Geoptimaliseerde Krachten)</option>
                    </select>
                </div>

                <!-- Dynamic Controls Container -->
                <div id="dynamicControls" class="col-span-1 sm:col-span-2">
                    <!-- Charge Slider (Default for Force) -->
                    <div id="chargeControl" class="">
                        <label for="chargeSlider" class="block text-sm font-medium text-gray-700 mb-1">
                            Afstotende Kracht (Sterkte: <span id="chargeValue">-600</span>)
                        </label>
                        <input type="range" id="chargeSlider" min="-3000" max="-100" value="-600" step="50" oninput="document.getElementById('chargeValue').innerText = this.value" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>

                    <!-- Hierarchical Direction Control (Hidden by default) -->
                    <div id="directionControl" class="hidden">
                        <label for="directionSelect" class="block text-sm font-medium text-gray-700 mb-1">Richting</label>
                        <select id="directionSelect" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                            <option value="TB">Boven naar Onder</option>
                            <option value="LR">Links naar Rechts</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Turtle Input -->
            <label for="turtleInput" class="block text-sm font-medium text-gray-700 mb-2">Uw Turtle Invoer</label>
            <textarea id="turtleInput" rows="8" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-sm font-mono" placeholder="ex:Jane ex:hasHobby ex:Coding .
ex:Coding ex:isTopicOf ex:Article .
ex:Jane ex:isFriendOf ex:Mark .
ex:Mark ex:hasHobby ex:Photography .
ex:Jane ex:age 35 .
ex:Article ex:isAbout &quot;Knowledge Graph&quot; .">@prefix ex: <http://example.org/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

ex:Jane ex:hasHobby ex:Coding .
ex:Coding ex:isTopicOf ex:Article .
ex:Jane ex:isFriendOf ex:Mark .
ex:Mark ex:hasHobby ex:Photography .
ex:Jane ex:age "35"^^xsd:integer .
ex:Article ex:isAbout "Knowledge Graph" .
</textarea>
            <button onclick="parseTurtleAndDraw()" class="mt-4 w-full sm:w-auto px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-150">
                Genereer Grafiek
            </button>
        </div>

        <!-- Graph Visualization Area -->
        <div id="graph-container">
            <!-- SVG zal hier worden geïnjecteerd door D3.js -->
        </div>
    </div>

    <script>
        // Global D3 variables
        let svg, width, height, simulation, linksGroup, nodesGroup, linksTextGroup, nodesTextGroup, link, node, nodeLabel, linkLabel;

        // Nieuwe cleanId om N3.js's volledige URI's en literals te verwerken
        const cleanId = (id) => {
            if (!id || typeof id !== 'string') return String(id);

            // 1. Handle Literals (N3 output includes ^ and language tags)
            if (id.startsWith('"')) {
                // Strip quotes, language tags, and datatypes for display simplicity
                return id.split("^^")[0].split("@")[0].replace(/"/g, '');
            }

            // 2. Handle URIs (Take the part after the last / or #)
            let parts = id.split(/#|\//);
            let shortId = parts[parts.length - 1];

            return shortId || id;
        };

        // --- Parsing Logic (Uses N3.js library) ---
        function parseTurtle(turtleText) {
            return new Promise((resolve, reject) => {
                if (typeof N3 === 'undefined' || typeof N3.Parser === 'undefined') {
                    const msg = "N3.js library niet geladen. Kan Turtle niet parsen.";
                    console.error(msg);
                    return reject(new Error(msg));
                }

                // De parser heeft xsd nodig als prefix als we datatypes gebruiken
                let parser = new N3.Parser({
                    baseIRI: 'http://example.org/',
                    prefixes: {
                        xsd: 'http://www.w3.org/2001/XMLSchema#'
                    }
                });

                const nodesSet = new Set();
                const links = [];

                parser.parse(turtleText, (error, triple) => {
                    if (error) {
                        console.error("N3 Parse Error:", error);
                        // Bij een parseerfout, resolven we met lege data om een crash te voorkomen
                        return resolve({ nodes: [], links: [] });
                    }
                    if (triple) {
                        // N3.js geeft volledige URI's en literals terug
                        const subject = triple.subject.value;
                        const predicate = triple.predicate.value;
                        const object = triple.object.value;
                        const isLiteral = triple.object.termType === 'Literal';

                        nodesSet.add(subject);
                        if (!isLiteral) {
                            nodesSet.add(object);
                        }

                        links.push({
                            source: subject,
                            target: object,
                            label: predicate,
                            isLiteral: isLiteral
                        });
                    } else {
                        // Done parsing

                        const nodes = Array.from(nodesSet).map(id => ({
                            id: id,
                            cleanId: cleanId(id),
                            isLiteral: id.startsWith('"')
                        }));

                        // Zorg ervoor dat literal targets ook als knooppunten worden toegevoegd
                        links.forEach(l => {
                            if (l.isLiteral) {
                                if (!nodes.find(n => n.id === l.target)) {
                                    nodes.push({ id: l.target, cleanId: cleanId(l.target), isLiteral: true });
                                }
                            }
                            l.cleanLabel = cleanId(l.label);
                            // Sla de oorspronkelijke prefix op voor weergave
                            const uriParts = l.label.split(/#|\//);
                            l.prefix = uriParts.length > 1 ? l.label.substring(0, l.label.length - l.cleanLabel.length) : '';
                        });

                        resolve({ nodes, links });
                    }
                });
            });
        }

        // --- D3 Visualization Logic ---
        function initializeVisualization() {
            const container = document.getElementById('graph-container');

            // Clear previous SVG content
            d3.select("#graph-container").select("svg").remove();

            // Haal de initiële afmetingen op en stel SVG in
            onResize(); // <-- VROEGE OPROEP

            svg = d3.select("#graph-container")
                .append("svg")
                // Stelt de initiële schaalbare dimensies in
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", `0 0 ${width} ${height}`)
                .attr("preserveAspectRatio", "xMidYMid meet")
                .call(d3.zoom().on("zoom", function ({ transform }) {
                    g.attr("transform", transform)
                }))
                .on("dblclick.zoom", null); // Disable double click zoom

            const g = svg.append("g");

            // Define arrowhead markers
            g.append("defs").selectAll("marker")
                .data(["arrowhead_resource", "arrowhead_literal"]) // Twee types markers gedefinieerd
                .enter().append("marker")
                .attr("id", d => d)
                .attr("viewBox", "0 -5 10 10")
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", "#9ca3af");

            // Stel refX specifiek in voor elke marker
            // Resource nodes (r=18): refX = 18 + buffer (2) = 20
            g.select("#arrowhead_resource").attr("refX", 20);
            // Literal nodes (r=10): refX = 10 + buffer (2) = 12
            g.select("#arrowhead_literal").attr("refX", 12);

            linksGroup = g.append("g").attr("class", "links");
            nodesGroup = g.append("g").attr("class", "nodes");
            linksTextGroup = g.append("g").attr("class", "link-labels");
            nodesTextGroup = g.append("g").attr("class", "node-labels");

            // Initialiseer simulatie, de krachten worden geüpdatet in updateVisualization
            simulation = d3.forceSimulation()
                .force("link", d3.forceLink().id(d => d.id).distance(120))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("x", d3.forceX(width / 2).strength(0.2))
                .force("y", d3.forceY(height / 2).strength(0.2));

            window.addEventListener('resize', onResize);
        }

        // Functie om de zichtbaarheid van de controls aan te passen
        function toggleLayoutControls() {
            const layout = document.getElementById('layoutSelect').value;
            const chargeControl = document.getElementById('chargeControl');
            const directionControl = document.getElementById('directionControl');

            if (layout === 'force') {
                chargeControl.classList.remove('hidden');
                directionControl.classList.add('hidden');
            } else if (layout === 'hierarchical') {
                chargeControl.classList.add('hidden');
                directionControl.classList.remove('hidden');
            }
        }

        function onResize() {
            const container = document.getElementById('graph-container');
            width = container.clientWidth;
            height = container.clientHeight;

            // Alleen SVG-dimensies updaten als SVG al bestaat
            if (svg) {
                // Update SVG width/height en de viewBox voor schaalbaarheid
                svg.attr("width", width).attr("height", height);
                svg.attr("viewBox", `0 0 ${width} ${height}`);
            }

            // Pas de centrumkracht aan bij resize
            if (simulation) {
                simulation.force("center", d3.forceCenter(width / 2, height / 2));
            }

            // Als de layout niet force directed is, moet de layout opnieuw berekend en getekend worden
            if (document.getElementById('layoutSelect').value === 'hierarchical') {
                // Herstart de volledige tekening met de huidige data in de textarea
                parseTurtleAndDraw(true);
            } else if (simulation) {
                 simulation.alpha(0.5).restart(); // Hogere alpha voor snellere settling bij resize
            }
        }

        // NIEUW: Ticked functie verplaatst naar globaal bereik
        function ticked() {
            // Deze functie wordt nu gebruikt voor BEIDE layouts, maar de link update is anders
            const layout = document.getElementById('layoutSelect').value;

            if (layout === 'force') {
                // Force Directed: gebruik rechte lijnen
                link.attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
            } else {
                // Hierarchisch: gebruik rechte lijnen (we laten de Leveling Force het werk doen)
                link.attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);
            }

            // Node circle positions
            node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y);

            // Node label positions
            nodeLabel
                .attr("x", d => d.x)
                .attr("y", d => d.y);

            // Link label positions (midpoint of link)
            linkLabel
                .attr("x", d => (d.source.x + d.target.x) / 2)
                .attr("y", d => (d.source.y + d.target.y) / 2 - 12);
        }

        // Nieuwe helper om het niveau van de knooppunten te berekenen (BFS)
        function calculateNodeLevels(nodes, links, rootId, direction, width, height) {
            const nodeMap = new Map(nodes.map(n => [n.id, n]));
            const adjacencyMap = new Map();
            links.forEach(link => {
                if (!adjacencyMap.has(link.source)) {
                    adjacencyMap.set(link.source, []);
                }
                adjacencyMap.get(link.source).push(link.target);
            });

            // Level bepaling
            nodes.forEach(n => n.level = -1);
            if (!nodeMap.has(rootId)) return;

            nodeMap.get(rootId).level = 0;
            const queue = [rootId];
            let level = 0;
            let currentLevelSize = 1;
            let nextLevelSize = 0;

            while (queue.length > 0) {
                const currentId = queue.shift();
                currentLevelSize--;
                const currentNode = nodeMap.get(currentId);

                const targets = adjacencyMap.get(currentId) || [];
                targets.forEach(targetId => {
                    const targetNode = nodeMap.get(targetId);
                    // Voorkom loops en zorg ervoor dat alleen onbezochte knopen worden geüpdatet
                    if (targetNode && targetNode.level === -1) {
                        targetNode.level = currentNode.level + 1;
                        queue.push(targetId);
                        nextLevelSize++;
                    }
                });

                if (currentLevelSize === 0) {
                    currentLevelSize = nextLevelSize;
                    nextLevelSize = 0;
                    level++;
                }
            }

            // Bepaal het totale aantal niveaus en de spacing
            const maxLevel = nodes.reduce((max, n) => Math.max(max, n.level), 0);
            const totalSpace = direction === 'TB' ? height * 0.9 : width * 0.9;
            const spacing = totalSpace / (maxLevel + 1);
            const margin = (direction === 'TB' ? height : width) * 0.05;

            // Wijs de doelfixatiepunten (fx, fy) toe
            nodes.forEach(n => {
                if (n.level !== -1) {
                    const targetPosition = margin + n.level * spacing;
                    if (direction === 'TB') {
                        // Boven naar Onder: Y-positie is vast
                        n.fy = targetPosition;
                    } else {
                        // Links naar Rechts: X-positie is vast
                        n.fx = targetPosition;
                    }
                } else {
                    // Losse knopen naar het midden forceren
                    n.fx = width / 2;
                    n.fy = height / 2;
                }

                // Initialiseer positie op fixatiepunt voor snelle settling
                n.x = n.fx !== null ? n.fx : width / 2;
                n.y = n.fy !== null ? n.fy : height / 2;
            });
        }

        function updateVisualization(nodes, links, skipRestart = false) {
            // Reset ALL position properties before starting any layout logic - CRUCIAAL
            nodes.forEach(d => {
                d.x = null;
                d.y = null;
                d.fx = null;
                d.fy = null;
            });

            // Pas de kracht aan op basis van de slider
            const layout = document.getElementById('layoutSelect').value;
            const chargeStrength = parseInt(document.getElementById('chargeSlider').value);
            const container = document.getElementById('graph-container');
            width = container.clientWidth;
            height = container.clientHeight;

            // CRUCIAAL: Maak de groepen leeg om oude elementen te verwijderen
            linksGroup.html("");
            nodesGroup.html("");
            linksTextGroup.html("");
            nodesTextGroup.html("");

            // --- LAYOUT SWITCH LOGIC ---
            if (layout === 'force') {
                // Force Directed Layout (Standaard)
                simulation
                    .force("charge", d3.forceManyBody().strength(chargeStrength))
                    .force("center", d3.forceCenter(width / 2, height / 2))
                    .force("x", d3.forceX(width / 2).strength(0.2))
                    .force("y", d3.forceY(height / 2).strength(0.2))
                    .alphaTarget(0.1);


            } else if (layout === 'hierarchical') {
                // --- Leveling Force Hiërarchische Layout ---

                // 1. Bepaal de (Arbitraire) Root en bereken levels (opnieuw)
                let rootId = nodes.length > 0 ? nodes[0].id : null;
                if (nodes.length > 1) {
                    const outgoingCount = nodes.map(n => ({ id: n.id, count: links.filter(l => l.source === n.id).length }));
                    const maxOutgoing = outgoingCount.reduce((max, current) => current.count > max.count ? current : max, outgoingCount[0]);
                    rootId = maxOutgoing.id;
                }

                const direction = document.getElementById('directionSelect').value;
                calculateNodeLevels(nodes, links, rootId, direction, width, height);

                // 2. Pas krachten toe op basis van de berekende fx/fy punten
                simulation
                    .force("charge", d3.forceManyBody().strength(-300)) // Zachte afstoting om overlapping te voorkomen
                    .force("center", d3.forceCenter(width / 2, height / 2).strength(0)) // Centrifugeer uit
                    .force("link", d3.forceLink().id(d => d.id).distance(150)) // Grotere afstand tussen lagen
                    .alphaTarget(0.1);

                if (direction === 'TB') {
                    // Boven/Onder: Y is vast, X is zacht/force
                    simulation.force("levelY", d3.forceY(d => d.fy).strength(1)); // Sterke Y-kracht
                    simulation.force("levelX", d3.forceX(width / 2).strength(0.01)); // Zwakke X-kracht
                } else {
                    // Links/Rechts: X is vast, Y is zacht/force
                    simulation.force("levelX", d3.forceX(d => d.fx).strength(1)); // Sterke X-kracht
                    simulation.force("levelY", d3.forceY(height / 2).strength(0.01)); // Zwakke Y-kracht
                }
            } // Einde layout switch

            // Bind data to simulation
            simulation.nodes(nodes).on("tick", ticked);
            simulation.force("link").links(links);

            // Restart simulatie
            simulation.alpha(1).restart();

            // Update D3 elementen
            // De link elementen zijn nu altijd rechte lijnen (<line>)
            const linkTag = 'line';

            link = linksGroup.selectAll(".link")
                .data(links, d => d.source.id + "-" + d.target.id)
                .enter().append(linkTag)
                .attr("class", "link")
                .attr("marker-end", d => {
                    // CRUCIAAL: Dynamische toewijzing van de juiste marker
                    if (d.target && d.target.isLiteral) {
                        return "url(#arrowhead_literal)";
                    }
                    return "url(#arrowhead_resource)";
                });

            // Update nodes (circles)
            node = nodesGroup.selectAll("circle.node-circle")
                .data(nodes, d => d.id)
                .enter().append("circle")
                .attr("class", "node-circle")
                .attr("r", d => d.isLiteral ? 10 : 18)
                .attr("fill", d => d.isLiteral ? "#fcd34d" : "#4f46e5")
                .call(drag(simulation));

            // Update node labels
            nodeLabel = nodesTextGroup.selectAll("text.node-label")
                .data(nodes, d => d.id)
                .enter().append("text")
                .attr("class", "node-label")
                .attr("dy", d => d.isLiteral ? -15 : 25)
                .attr("text-anchor", "middle")
                .style("font-size", d => d.isLiteral ? "11px" : "13px")
                .text(d => d.cleanId);

            // Update link labels
            linkLabel = linksTextGroup.selectAll("text.link-label")
                .data(links, d => d.source.id + "-" + d.target.id)
                .enter().append("text")
                .attr("class", "link-label")
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .text(d => {
                    // NIEUW: Geef het label weer als 'prefix:naam'
                    let prefix = d.prefix.split(/#|\//);
                    prefix = prefix.length > 1 ? prefix[prefix.length - 2] : '';
                    if (prefix && prefix !== d.cleanLabel) {
                         return `${prefix}:` + d.cleanLabel;
                    }
                    return d.cleanLabel;
                });
        }

        // Drag functionality for nodes
        const drag = simulation => {
            function dragstarted(event, d) {
                // In beide lay-outs gebruiken we de simulatie, maar met andere krachten
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                // In hiërarchische lay-out blijft de fixatie behouden na het slepen
                if (document.getElementById('layoutSelect').value !== 'hierarchical') {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null; // Release node to physics simulation
                    d.fy = null;
                }
            }

            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }

        // Main function to run when the button is clicked (nu asynchroon)
        async function parseTurtleAndDraw(isResize = false) {
            const turtleText = document.getElementById('turtleInput').value;

            if (!svg) {
                initializeVisualization();
            }

            // Haal de afmetingen op om het bericht te centreren
            const container = document.getElementById('graph-container');
            const currentWidth = container.clientWidth;
            const currentHeight = container.clientHeight;

            if (!isResize) {
                // Verwijder oude grafiek en toon 'parsing' bericht (alleen bij nieuwe parsing, niet bij resize)
                linksGroup.html('<text x="' + currentWidth/2 + '" y="' + currentHeight/2 + '" text-anchor="middle" fill="#1f2937">Bezig met parsen...</text>');
                nodesGroup.html("");
                linksTextGroup.html("");
                nodesTextGroup.html("");
            }


            try {
                // Gebruik de N3.js parser
                const graphData = await parseTurtle(turtleText);

                if (graphData.nodes.length === 0 && graphData.links.length === 0) {
                    // Als de data leeg is, wis alles en toon bericht
                    linksGroup.html('<text x="' + currentWidth/2 + '" y="' + currentHeight/2 + '" text-anchor="middle" fill="#1f2937">Geen geldige triples gevonden.</text>');
                    console.error("Geen triples gevonden. Controleer de syntaxis.");
                    return;
                }

                updateVisualization(graphData.nodes, graphData.links);
            } catch (e) {
                console.error("Fout bij het parsen van Turtle:", e);
                // Toon fout op scherm
                linksGroup.html('<text x="' + currentWidth/2 + '" y="' + currentHeight/2 + '" text-anchor="middle" fill="#cc0000">Fout bij het parsen: ' + e.message + '</text>');
            }
        }

        // Initialize visualization and draw the example graph on load
        window.onload = function() {
             toggleLayoutControls(); // Zet initiële zichtbaarheid van controls
             initializeVisualization();
             parseTurtleAndDraw(); // Draw the default example
        }
    </script>
</body>
</html>