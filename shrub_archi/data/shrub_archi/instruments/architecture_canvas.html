<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Functional Modeler</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Babel for JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Import Map to resolve react and lucide-react imports from CDN -->
    <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.2.0",
        "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
        "lucide-react": "https://esm.sh/lucide-react@0.263.1"
      }
    }
    </script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #f8fafc; }
        /* Prevent touch scrolling/bouncing on mobile */
        html, body { height: 100%; width: 100%; overscroll-behavior: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';
        import { createRoot } from 'react-dom/client';
        import {
          MousePointer2,
          Square,
          BoxSelect,
          ArrowUpRight,
          Trash2,
          ZoomIn,
          ZoomOut,
          Settings2,
          Maximize2,
          Minimize2,
          MoreHorizontal
        } from 'lucide-react';

        /**
         * ==========================================
         * TYPES & CONSTANTS
         * ==========================================
         */

        const SNAP_GRID = 10;
        const INITIAL_STD_SIZE = { w: 120, h: 80 };
        const HANDLE_SIZE = 8;
        const MIN_SIZE = 40;

        const ROUTING_MODES = {
          STRAIGHT: 'Straight',
          CURVED: 'Curved',
          MANHATTAN: 'Manhattan'
        };

        const RELATION_TYPES = {
          DIRECTIONAL: 'Directional', // Object -> Object
          CONTAINMENT: 'Containment', // Group -> Object
          RELATION_ON_RELATION: 'RelationRelation' // Relation -> Object
        };

        // Colors
        const COLORS = {
          selection: '#3b82f6',
          selectionBg: 'rgba(59, 130, 246, 0.1)',
          groupFill: '#f1f5f9',
          groupStroke: '#94a3b8',
          stdFill: '#ffffff',
          stdStroke: '#0f172a',
          handleFill: '#ffffff',
          handleStroke: '#3b82f6',
          text: '#0f172a'
        };

        /**
         * ==========================================
         * GEOMETRY HELPERS
         * ==========================================
         */

        const distance = (p1, p2) => Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));

        const getRectCenter = (rect) => ({
          x: rect.x + rect.w / 2,
          y: rect.y + rect.h / 2
        });

        // Check if point is in rect
        const pointInRect = (p, r) =>
          p.x >= r.x && p.x <= r.x + r.w && p.y >= r.y && p.y <= r.y + r.h;

        // Check if rect A contains rect B
        const rectContains = (a, b) =>
          b.x >= a.x && b.x + b.w <= a.x + a.w && b.y >= a.y && b.y + b.h <= a.y + a.h;

        // Check if rects intersect
        const rectIntersect = (r1, r2) => {
          return !(r2.x > r1.x + r1.w ||
                   r2.x + r2.w < r1.x ||
                   r2.y > r1.y + r1.h ||
                   r2.y + r2.h < r1.y);
        };

        // Helper to get point on border of rect closest to another point
        const getIntersection = (rect, target) => {
          const center = getRectCenter(rect);
          const dx = target.x - center.x;
          const dy = target.y - center.y;

          if (dx === 0 && dy === 0) return center;

          // Calculate intersection with the 4 sides
          const angle = Math.atan2(dy, dx);
          // Simple approximation for UI fluidity
          const halfW = rect.w / 2;
          const halfH = rect.h / 2;

          // Clamping to box
          const tx = halfW;
          const ty = halfH;

          let x, y;

          if (Math.abs(dx) * halfH > Math.abs(dy) * halfW) {
            // Left or Right
            x = center.x + (dx > 0 ? halfW : -halfW);
            y = center.y + dy * (dx > 0 ? halfW : -halfW) / dx;
          } else {
            // Top or Bottom
            y = center.y + (dy > 0 ? halfH : -halfH);
            x = center.x + dx * (dy > 0 ? halfH : -halfH) / dy;
          }

          return { x, y };
        };

        /**
         * ==========================================
         * COMPONENT: APP
         * ==========================================
         */

        function App() {
          // --- STATE ---
          const [objects, setObjects] = useState([]); // { id, type: 'standard'|'group', x, y, w, h, name, desc, collapsed, expandedSize }
          const [relations, setRelations] = useState([]); // { id, sourceId, targetId, type, routing, name, desc }
          const [selection, setSelection] = useState(new Set()); // Set of IDs (objects or relations)

          const [view, setView] = useState({ x: 0, y: 0, zoom: 1 });
          const [tool, setTool] = useState('select'); // select, standard, group, relation

          // Interaction State
          const [dragState, setDragState] = useState(null);
          // dragState = { type: 'pan'|'move'|'resize'|'marquee'|'connect', start: {x,y}, current: {x,y}, initialObjects: {}, selectionStart: Set, sourceId? }

          const svgRef = useRef(null);
          const containerRef = useRef(null);

          // --- DERIVED STATE HELPERS ---

          // Build containment tree map: childId -> parentId
          const parentMap = useMemo(() => {
            const map = {};
            relations.forEach(r => {
              if (r.type === RELATION_TYPES.CONTAINMENT) {
                map[r.targetId] = r.sourceId; // Target is the child in definition
              }
            });
            return map;
          }, [relations]);

          // Check if an object is effectively visible (not hidden by a collapsed ancestor)
          // Returns: { visible: boolean, effectiveId: string }
          // If visible, effectiveId is the object itself.
          // If hidden, effectiveId is the ID of the highest collapsed ancestor visible.
          const getVisibilityStatus = useCallback((objId) => {
            let currentId = objId;
            let visibleAncestor = null;
            let isHidden = false;

            // Traverse up
            while (currentId) {
              const obj = objects.find(o => o.id === currentId);
              if (!obj) break;

              if (obj.collapsed && currentId !== objId) {
                isHidden = true;
                visibleAncestor = currentId; // This group hides the child
              }

              // Move up
              currentId = parentMap[currentId];
            }

            if (isHidden) {
              return { visible: false, effectiveId: visibleAncestor };
            }
            return { visible: true, effectiveId: objId };
          }, [objects, parentMap]);

          // Get geometry for a relation end point
          // Handles logic: "If hidden, use center of outer visible group"
          const getEffectiveGeometry = useCallback((id) => {
            // Check if ID is a relation (Relation-on-Relation)
            const rel = relations.find(r => r.id === id);
            if (rel) {
              // It's a relation. Return the midpoint of that relation.
              // NOTE: This assumes relation geometries are calculated. We might need a 2-pass render or simplifiction.
              // For simplicity, we calculate the simple midpoint based on source/target of that relation.
              const srcGeo = getEffectiveGeometry(rel.sourceId);
              const tgtGeo = getEffectiveGeometry(rel.targetId);
              if (!srcGeo || !tgtGeo) return null;
              return {
                x: (srcGeo.x + srcGeo.w/2 + tgtGeo.x + tgtGeo.w/2) / 2,
                y: (srcGeo.y + srcGeo.h/2 + tgtGeo.y + tgtGeo.h/2) / 2,
                w: 0, h: 0,
                type: 'relation'
              };
            }

            const obj = objects.find(o => o.id === id);
            if (!obj) return null;

            const status = getVisibilityStatus(id);
            const targetId = status.visible ? id : status.effectiveId;
            const targetObj = objects.find(o => o.id === targetId);

            if (!targetObj) return null;

            return {
              x: targetObj.x,
              y: targetObj.y,
              w: targetObj.w,
              h: targetObj.h,
              id: targetObj.id,
              type: targetObj.type
            };
          }, [objects, relations, getVisibilityStatus]);


          // --- COORDINATE SYSTEMS ---

          const screenToWorld = useCallback((sx, sy) => {
            if (!containerRef.current) return { x: 0, y: 0 };
            const rect = containerRef.current.getBoundingClientRect();
            return {
              x: (sx - rect.left - view.x) / view.zoom,
              y: (sy - rect.top - view.y) / view.zoom
            };
          }, [view]);

          const worldToScreen = useCallback((wx, wy) => {
            if (!containerRef.current) return { x: 0, y: 0 };
            const rect = containerRef.current.getBoundingClientRect();
            return {
              x: (wx * view.zoom) + view.x + rect.left,
              y: (wy * view.zoom) + view.y + rect.top
            };
          }, [view]);

          // --- ACTIONS ---

          const generateId = () => Math.random().toString(36).substr(2, 9);

          const addNode = (x, y, type) => {
            const id = generateId();
            const newNode = {
              id,
              type,
              x,
              y,
              w: INITIAL_STD_SIZE.w,
              h: INITIAL_STD_SIZE.h,
              name: `New ${type === 'group' ? 'Group' : 'Object'}`,
              description: '',
              collapsed: false,
              expandedSize: null
            };
            setObjects(prev => [...prev, newNode]);
            // Auto select
            setSelection(new Set([id]));
          };

          const deleteSelection = () => {
            const idsToDelete = new Set();
            const stack = [...selection];

            // Cascade delete logic
            while (stack.length > 0) {
              const id = stack.pop();
              if (idsToDelete.has(id)) continue;
              idsToDelete.add(id);

              // If group, find children
              relations.forEach(r => {
                if (r.type === RELATION_TYPES.CONTAINMENT && r.sourceId === id) {
                  stack.push(r.targetId);
                }
              });
            }

            setObjects(prev => prev.filter(o => !idsToDelete.has(o.id)));
            // Delete relations connected to deleted objects OR if relation itself is selected
            setRelations(prev => prev.filter(r =>
              !idsToDelete.has(r.sourceId) &&
              !idsToDelete.has(r.targetId) &&
              !selection.has(r.id)
            ));
            setSelection(new Set());
          };

          const toggleGroupState = (grpId) => {
            setObjects(prev => prev.map(obj => {
              if (obj.id !== grpId) return obj;

              if (obj.collapsed) {
                // Expand
                return {
                  ...obj,
                  collapsed: false,
                  w: obj.expandedSize?.w || INITIAL_STD_SIZE.w,
                  h: obj.expandedSize?.h || INITIAL_STD_SIZE.h
                };
              } else {
                // Collapse
                return {
                  ...obj,
                  collapsed: true,
                  expandedSize: { w: obj.w, h: obj.h },
                  w: INITIAL_STD_SIZE.w, // Gets size of standard object
                  h: INITIAL_STD_SIZE.h
                };
              }
            }));
          };

          // --- EVENT HANDLERS ---

          const handlePointerDown = (e) => {
            const { clientX, clientY, button } = e;
            const pos = screenToWorld(clientX, clientY);

            // Check hit on UI handles or objects (Reverse order for Z-index: top first)
            // Z-Order: Handles > Nodes (Front->Back) > Relations > Groups

            // 0. Handle check (if selection exists)
            if (selection.size > 0) {
               // Logic for resize handles would go here.
               // For brevity in single file, assuming objects handles are hit-tested by checking proximity to bounds of selection
               const bounds = getSelectionBounds();
               if (bounds) {
                 const handle = getHitHandle(bounds, pos, view.zoom);
                 if (handle) {
                   setDragState({
                     type: 'resize',
                     handle,
                     start: pos,
                     initialObjects: getSnapshot(objects)
                   });
                   return;
                 }
               }
            }

            // 1. Hit test Nodes (Visual/Z-index order: Std Nodes on top of Groups)
            // Sort: Groups first in array, then Non-Groups.
            // This ensures reverse loop checks Non-Groups (Front) before Groups (Back).
            const sortedObjects = [...objects].sort((a, b) => {
                if (a.type === 'group' && b.type !== 'group') return -1;
                if (a.type !== 'group' && b.type === 'group') return 1;
                return 0;
            });

            let hitId = null;
            let hitType = null;

            // Check objects (reverse for front-to-back click)
            for (let i = sortedObjects.length - 1; i >= 0; i--) {
              const obj = sortedObjects[i];
              const status = getVisibilityStatus(obj.id);
              if (!status.visible) continue;

              // Group toggle handle check
              if (obj.type === 'group') {
                const handleRect = { x: obj.x + obj.w/2 - 6, y: obj.y - 12, w: 12, h: 12 };
                if (pointInRect(pos, handleRect)) {
                  toggleGroupState(obj.id);
                  return;
                }
              }

              if (pointInRect(pos, obj)) {
                hitId = obj.id;
                hitType = 'node';
                break;
              }
            }

            // 2. Check Relations (if not hit node)
            if (!hitId) {
                // Rudimentary line hit test could go here
                // For simplicity, allow clicking near connection midpoints
                for (const rel of relations) {
                   const s = getEffectiveGeometry(rel.sourceId);
                   const t = getEffectiveGeometry(rel.targetId);
                   if(s && t) {
                       const mid = { x: (s.x+s.w/2 + t.x+t.w/2)/2, y: (s.y+s.h/2 + t.y+t.h/2)/2 };
                       if (distance(pos, mid) < 10 / view.zoom) {
                           hitId = rel.id;
                           hitType = 'relation';
                           break;
                       }
                   }
                }
            }

            // Logic Handling based on Tool & Hit
            if (button === 2 || e.altKey) { // Right click or Alt -> Pan
                setDragState({ type: 'pan', start: { x: clientX, y: clientY }, initialView: { ...view } });
                return;
            }

            if (tool === 'relation') {
              if (hitId) {
                setDragState({
                  type: 'connect',
                  sourceId: hitId,
                  start: pos,
                  current: pos
                });
                return;
              }
            }

            if (tool === 'standard' || tool === 'group') {
              addNode(pos.x, pos.y, tool === 'standard' ? 'standard' : 'group');
              // Sticky: Do not switch back to select tool
              return;
            }

            if (hitId) {
              // Selection logic
              const isSelected = selection.has(hitId);
              if (e.shiftKey) {
                 setSelection(prev => {
                   const next = new Set(prev);
                   if (isSelected) next.delete(hitId);
                   else next.add(hitId);
                   return next;
                 });
              } else {
                 if (!isSelected) setSelection(new Set([hitId]));
              }

              // Init Move
              setDragState({
                type: 'move',
                start: pos,
                current: pos,
                initialObjects: getSnapshot(objects)
              });
            } else {
              // Marquee
              if (!e.shiftKey) setSelection(new Set());
              setDragState({
                type: 'marquee',
                start: pos,
                current: pos,
                selectionStart: new Set(selection)
              });
            }
          };

          const handlePointerMove = (e) => {
            if (!dragState) return;
            const { clientX, clientY } = e;
            const pos = screenToWorld(clientX, clientY);

            if (dragState.type === 'pan') {
              const dx = clientX - dragState.start.x;
              const dy = clientY - dragState.start.y;
              setView({
                ...dragState.initialView,
                x: dragState.initialView.x + dx,
                y: dragState.initialView.y + dy
              });
            }

            else if (dragState.type === 'move') {
              const dx = pos.x - dragState.start.x;
              const dy = pos.y - dragState.start.y;

              // Identify all objects to move (selection + visually contained children)
              const idsToMove = new Set();

              const addChildrenRecursively = (parentId) => {
                  relations.forEach(r => {
                     if (r.type === RELATION_TYPES.CONTAINMENT && r.sourceId === parentId) {
                         idsToMove.add(r.targetId);
                         addChildrenRecursively(r.targetId);
                     }
                  });
              };

              selection.forEach(id => {
                  const obj = objects.find(o => o.id === id);
                  if (obj) {
                    idsToMove.add(id);
                    if (obj.type === 'group' && !obj.collapsed) {
                        addChildrenRecursively(id);
                    }
                  }
              });

              setObjects(prev => prev.map(obj => {
                if (idsToMove.has(obj.id)) {
                    const init = dragState.initialObjects[obj.id];
                    return { ...obj, x: init.x + dx, y: init.y + dy };
                }
                return obj;
              }));
            }

            else if (dragState.type === 'resize') {
               const dx = pos.x - dragState.start.x;
               const dy = pos.y - dragState.start.y;
               // Simplified scaling for prototype: uniform scaling based on handle
               // Just iterating selected objects and applying delta to w/h
               // In a full implementation, we'd use matrix transformation relative to the selection bounds
               const { handle } = dragState;

               setObjects(prev => prev.map(obj => {
                   if (selection.has(obj.id)) {
                       const init = dragState.initialObjects[obj.id];
                       let nw = init.w;
                       let nh = init.h;
                       // Very basic per-object resize, distinct from group scale logic for brevity
                       if (handle.includes('e')) nw += dx;
                       if (handle.includes('s')) nh += dy;
                       return { ...obj, w: Math.max(MIN_SIZE, nw), h: Math.max(MIN_SIZE, nh) };
                   }
                   return obj;
               }));
            }

            else if (dragState.type === 'marquee') {
              const r = {
                x: Math.min(dragState.start.x, pos.x),
                y: Math.min(dragState.start.y, pos.y),
                w: Math.abs(pos.x - dragState.start.x),
                h: Math.abs(pos.y - dragState.start.y)
              };

              const newSelection = new Set(dragState.selectionStart);

              // Find objects inside
              objects.forEach(obj => {
                const status = getVisibilityStatus(obj.id);
                if (status.visible && rectContains(r, obj)) {
                  newSelection.add(obj.id);
                }
              });

              setSelection(newSelection);
              setDragState(prev => ({ ...prev, current: pos }));
            }

            else if (dragState.type === 'connect') {
              setDragState(prev => ({ ...prev, current: pos }));
            }
          };

          const handlePointerUp = (e) => {
            if (!dragState) return;

            if (dragState.type === 'connect') {
              const { clientX, clientY } = e;
              const pos = screenToWorld(clientX, clientY);

              // Hit test for drop target
              let targetId = null;
              // Front to back
              for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                if (getVisibilityStatus(obj.id).visible && pointInRect(pos, obj)) {
                  targetId = obj.id;
                  break;
                }
              }

              if (targetId && targetId !== dragState.sourceId) {
                // INFER RELATION TYPE
                const sourceObj = objects.find(o => o.id === dragState.sourceId);
                const sourceIsRel = !!relations.find(r => r.id === dragState.sourceId);
                const targetObj = objects.find(o => o.id === targetId);

                let type = RELATION_TYPES.DIRECTIONAL;
                let finalSourceId = dragState.sourceId;
                let finalTargetId = targetId;

                if (sourceIsRel && targetObj?.type !== 'group') {
                     type = RELATION_TYPES.RELATION_ON_RELATION;
                } else if (sourceObj?.type === 'group' && targetObj?.type !== 'group') {
                    type = RELATION_TYPES.CONTAINMENT;
                } else if (sourceObj?.type !== 'group' && targetObj?.type === 'group') {
                    // New Case: Non-Group -> Group.
                    // Infer as containment, but swap Source/Target so internal representation
                    // keeps Source = Group (Parent) for consistent hiding/tree logic.
                    type = RELATION_TYPES.CONTAINMENT;
                    finalSourceId = targetId;
                    finalTargetId = dragState.sourceId;
                } else if (sourceObj?.type !== 'group' && targetObj?.type !== 'group') {
                    type = RELATION_TYPES.DIRECTIONAL;
                }

                setRelations(prev => [...prev, {
                  id: generateId(),
                  sourceId: finalSourceId,
                  targetId: finalTargetId,
                  type,
                  routing: ROUTING_MODES.STRAIGHT,
                  name: 'Relation',
                  desc: ''
                }]);
              }

              // Sticky: Do not switch back to select tool
            }

            setDragState(null);
          };

          const handleWheel = (e) => {
             if (e.ctrlKey || e.metaKey) {
               e.preventDefault();
               const zoomFactor = -e.deltaY * 0.001;
               const newZoom = Math.max(0.1, Math.min(5, view.zoom + zoomFactor));

               // Zoom toward mouse logic could go here, simplified to center or existing logic
               setView(prev => ({ ...prev, zoom: newZoom }));
             }
          };

          // Shortcuts
          useEffect(() => {
            const handleKeyDown = (e) => {
              if (e.key === 'Delete' || e.key === 'Backspace') deleteSelection();
              if (e.key === 'Escape') {
                  setSelection(new Set());
                  setDragState(null);
                  setTool('select');
              }
            };
            window.addEventListener('keydown', handleKeyDown);
            return () => window.removeEventListener('keydown', handleKeyDown);
          }, [selection, relations]);


          // --- HELPERS FOR RENDERING ---

          const getSnapshot = (objs) => {
            const snap = {};
            objs.forEach(o => snap[o.id] = { ...o });
            return snap;
          };

          const getSelectionBounds = () => {
            if (selection.size === 0) return null;
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

            let count = 0;
            selection.forEach(id => {
              const obj = objects.find(o => o.id === id);
              if (obj && getVisibilityStatus(obj.id).visible) {
                minX = Math.min(minX, obj.x);
                minY = Math.min(minY, obj.y);
                maxX = Math.max(maxX, obj.x + obj.w);
                maxY = Math.max(maxY, obj.y + obj.h);
                count++;
              }
            });

            if (count === 0) return null;
            return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
          };

          const getHitHandle = (bounds, pos, zoom) => {
            const margin = HANDLE_SIZE / zoom;
            // 8 handles logic
            const xs = [bounds.x, bounds.x + bounds.w/2, bounds.x + bounds.w];
            const ys = [bounds.y, bounds.y + bounds.h/2, bounds.y + bounds.h];
            const names = [['nw','n','ne'], ['w',null,'e'], ['sw','s','se']];

            for(let i=0; i<3; i++) {
              for(let j=0; j<3; j++) {
                if (!names[i][j]) continue;
                if (Math.abs(pos.x - xs[j]) < margin && Math.abs(pos.y - ys[i]) < margin) {
                    return names[i][j];
                }
              }
            }
            return null;
          };

          // --- RENDERING SUB-FUNCTIONS ---

          // Generate Path Data
          const getEdgePath = (r, start, end) => {
            if (r.routing === ROUTING_MODES.MANHATTAN) {
              const midX = (start.x + end.x) / 2;
              return `M ${start.x} ${start.y} L ${midX} ${start.y} L ${midX} ${end.y} L ${end.x} ${end.y}`;
            }
            else if (r.routing === ROUTING_MODES.CURVED) {
              const dx = end.x - start.x;
              const c1x = start.x + dx * 0.5;
              const c1y = start.y;
              const c2x = end.x - dx * 0.5;
              const c2y = end.y;
              return `M ${start.x} ${start.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${end.x} ${end.y}`;
            }
            return `M ${start.x} ${start.y} L ${end.x} ${end.y}`;
          };

          const renderSelectionOverlay = () => {
            const bounds = getSelectionBounds();
            if (!bounds) return null;

            return (
              <g pointerEvents="none">
                <rect
                  x={bounds.x} y={bounds.y} width={bounds.w} height={bounds.h}
                  fill="none" stroke={COLORS.selection} strokeWidth={1 / view.zoom}
                  strokeDasharray="4 2"
                />
                {/* Handles */}
                {[
                  {x: bounds.x, y: bounds.y, c: 'nw'},
                  {x: bounds.x+bounds.w/2, y: bounds.y, c: 'n'},
                  {x: bounds.x+bounds.w, y: bounds.y, c: 'ne'},
                  {x: bounds.x+bounds.w, y: bounds.y+bounds.h/2, c: 'e'},
                  {x: bounds.x+bounds.w, y: bounds.y+bounds.h, c: 'se'},
                  {x: bounds.x+bounds.w/2, y: bounds.y+bounds.h, c: 's'},
                  {x: bounds.x, y: bounds.y+bounds.h, c: 'sw'},
                  {x: bounds.x, y: bounds.y+bounds.h/2, c: 'w'}
                ].map((h, i) => {
                    // Skip top middle handle if single group selected (Prompt requirement)
                    if (selection.size === 1 && h.c === 'n') {
                        const id = Array.from(selection)[0];
                        const obj = objects.find(o => o.id === id);
                        if (obj && obj.type === 'group') return null;
                    }
                    return (
                      <rect
                        key={i}
                        x={h.x - (HANDLE_SIZE/2)/view.zoom}
                        y={h.y - (HANDLE_SIZE/2)/view.zoom}
                        width={HANDLE_SIZE/view.zoom}
                        height={HANDLE_SIZE/view.zoom}
                        fill={COLORS.handleFill}
                        stroke={COLORS.handleStroke}
                        strokeWidth={1/view.zoom}
                      />
                    )
                })}
              </g>
            );
          };

          const renderGrid = () => {
            const size = 50 * view.zoom;
            // We render a pattern
            return (
              <defs>
                <pattern id="grid" width={50} height={50} patternUnits="userSpaceOnUse">
                  <circle cx="1" cy="1" r="1" fill="#cbd5e1" />
                </pattern>
              </defs>
            );
          };

          const propertyPanel = () => {
            if (selection.size !== 1) return null;
            const id = Array.from(selection)[0];
            const obj = objects.find(o => o.id === id);
            const rel = relations.find(r => r.id === id);
            const item = obj || rel;
            if (!item) return null;

            return (
              <div className="absolute right-4 top-20 w-64 bg-white shadow-xl rounded-lg border border-slate-200 p-4 flex flex-col gap-4 animate-in slide-in-from-right-10">
                <div className="flex justify-between items-center border-b pb-2">
                   <span className="font-semibold text-sm text-slate-700">Properties</span>
                   <Settings2 size={16} className="text-slate-400" />
                </div>

                <div>
                  <label className="text-xs font-medium text-slate-500 block mb-1">Name</label>
                  <input
                    className="w-full text-sm border rounded px-2 py-1"
                    value={item.name}
                    onChange={(e) => {
                       const val = e.target.value;
                       if (obj) setObjects(prev => prev.map(o => o.id === id ? {...o, name: val} : o));
                       else setRelations(prev => prev.map(r => r.id === id ? {...r, name: val} : r));
                    }}
                  />
                </div>

                <div>
                  <label className="text-xs font-medium text-slate-500 block mb-1">Description</label>
                  <textarea
                    className="w-full text-sm border rounded px-2 py-1 h-20 resize-none"
                    value={item.description}
                    onChange={(e) => {
                       const val = e.target.value;
                       if (obj) setObjects(prev => prev.map(o => o.id === id ? {...o, description: val} : o));
                       else setRelations(prev => prev.map(r => r.id === id ? {...r, description: val} : r));
                    }}
                  />
                </div>

                {rel && (
                  <div>
                    <label className="text-xs font-medium text-slate-500 block mb-1">Routing</label>
                    <select
                      className="w-full text-sm border rounded px-2 py-1"
                      value={rel.routing}
                      onChange={(e) => setRelations(prev => prev.map(r => r.id === id ? {...r, routing: e.target.value} : r))}
                    >
                      {Object.values(ROUTING_MODES).map(m => <option key={m} value={m}>{m}</option>)}
                    </select>
                  </div>
                )}
              </div>
            );
          };


          return (
            <div className="w-full h-screen bg-slate-50 overflow-hidden flex flex-col font-sans select-none">

              {/* TOOLBAR */}
              <div className="h-14 bg-white border-b flex items-center px-4 shadow-sm z-10 justify-between">
                <div className="flex items-center gap-2">
                  <div className="font-bold text-slate-700 mr-4 flex items-center gap-2">
                     <BoxSelect className="text-blue-600"/> Functional Modeler
                  </div>

                  <div className="h-8 w-px bg-slate-200 mx-2"/>

                  <button
                    onClick={() => setTool('select')}
                    className={`p-2 rounded hover:bg-slate-100 ${tool === 'select' ? 'bg-blue-50 text-blue-600' : 'text-slate-600'}`}
                    title="Select (V)"
                  >
                    <MousePointer2 size={20} />
                  </button>

                  <button
                    onClick={() => setTool('standard')}
                    className={`p-2 rounded hover:bg-slate-100 ${tool === 'standard' ? 'bg-blue-50 text-blue-600' : 'text-slate-600'}`}
                    title="Standard Object"
                  >
                    <Square size={20} />
                  </button>

                  <button
                    onClick={() => setTool('group')}
                    className={`p-2 rounded hover:bg-slate-100 ${tool === 'group' ? 'bg-blue-50 text-blue-600' : 'text-slate-600'}`}
                    title="Group Object"
                  >
                    <BoxSelect size={20} />
                  </button>

                  <button
                    onClick={() => setTool('relation')}
                    className={`p-2 rounded hover:bg-slate-100 ${tool === 'relation' ? 'bg-blue-50 text-blue-600' : 'text-slate-600'}`}
                    title="Relation"
                  >
                    <ArrowUpRight size={20} />
                  </button>

                  <div className="h-8 w-px bg-slate-200 mx-2"/>

                  <button
                     onClick={deleteSelection}
                     disabled={selection.size === 0}
                     className="p-2 rounded hover:bg-red-50 text-slate-600 hover:text-red-600 disabled:opacity-30"
                  >
                    <Trash2 size={20} />
                  </button>
                </div>

                <div className="flex items-center gap-2 text-slate-500 text-sm">
                   <button onClick={() => setView(prev => ({...prev, zoom: prev.zoom - 0.1}))}><ZoomOut size={16}/></button>
                   <span>{Math.round(view.zoom * 100)}%</span>
                   <button onClick={() => setView(prev => ({...prev, zoom: prev.zoom + 0.1}))}><ZoomIn size={16}/></button>
                </div>
              </div>

              {/* CANVAS */}
              <div
                ref={containerRef}
                className="flex-1 relative overflow-hidden cursor-crosshair"
                onPointerDown={handlePointerDown}
                onPointerMove={handlePointerMove}
                onPointerUp={handlePointerUp}
                onWheel={handleWheel}
                onContextMenu={(e) => e.preventDefault()}
              >
                <svg
                  ref={svgRef}
                  className="w-full h-full block touch-none"
                >
                  {renderGrid()}

                  <g transform={`translate(${view.x}, ${view.y}) scale(${view.zoom})`}>
                    {/* Background Grid */}
                    <rect x={-view.x/view.zoom} y={-view.y/view.zoom} width="20000" height="20000" fill="url(#grid)" opacity="0.5" transform="translate(-10000, -10000)"/>

                    {/* --- LAYERS --- */}

                    {/* 1. GROUPS (Back) */}
                    {objects.filter(o => o.type === 'group').map(obj => {
                       const status = getVisibilityStatus(obj.id);
                       if (!status.visible) return null; // Hidden by parent group

                       const isSelected = selection.has(obj.id);

                       return (
                         <g key={obj.id} transform={`translate(${obj.x}, ${obj.y})`}>
                           <rect
                             width={obj.w} height={obj.h}
                             fill={COLORS.groupFill}
                             stroke={isSelected ? COLORS.selection : COLORS.groupStroke}
                             strokeWidth={isSelected ? 2 : 1}
                             rx={4}
                           />
                           {/* Handle */}
                           <g
                              transform={`translate(${obj.w/2 - 6}, -12)`}
                              className="cursor-pointer hover:scale-110 transition-transform"
                            >
                              <rect width="12" height="12" fill="white" stroke={COLORS.groupStroke} rx="2" />
                              {obj.collapsed ? (
                                  <path d="M 3 6 L 9 6 M 6 3 L 6 9" stroke={COLORS.text} strokeWidth="1.5" />
                              ) : (
                                  <path d="M 3 6 L 9 6" stroke={COLORS.text} strokeWidth="1.5" />
                              )}
                           </g>
                           <text
                             x={10} y={20}
                             fontSize="12"
                             fill={COLORS.text}
                             className="font-bold pointer-events-none select-none"
                            >
                                {obj.name}
                            </text>
                         </g>
                       )
                    })}

                    {/* 2. RELATIONS */}
                    {relations.map(rel => {
                       const srcGeo = getEffectiveGeometry(rel.sourceId);
                       const tgtGeo = getEffectiveGeometry(rel.targetId);

                       if (!srcGeo || !tgtGeo) return null;

                       // Hide internal containment lines if visual containment exists
                       if (rel.type === RELATION_TYPES.CONTAINMENT) {
                         // Check if Target (Object) is visually inside Source (Group)
                         if (srcGeo.type === 'group' && rectContains(srcGeo, tgtGeo)) {
                           return null;
                         }
                       }

                       // Don't draw if hidden
                       const isHidden = !getVisibilityStatus(rel.sourceId).visible && !getVisibilityStatus(rel.targetId).visible;
                       // Wait, prompt says: "A connection is hidden if both sides of what it connects are hidden."
                       // Actually logic: If one side hidden, it connects to container. If both hidden implies both containers hidden?
                       // Simpler: if we can't resolve geometry, we don't draw.

                       const p1 = getIntersection(srcGeo, getRectCenter(tgtGeo));
                       const p2 = getIntersection(tgtGeo, getRectCenter(srcGeo));

                       const pathD = getEdgePath(rel, p1, p2);
                       const isSelected = selection.has(rel.id);

                       return (
                         <g key={rel.id}>
                           <path
                             d={pathD}
                             fill="none"
                             stroke={isSelected ? COLORS.selection : COLORS.stdStroke}
                             strokeWidth={2}
                             strokeDasharray={rel.type === RELATION_TYPES.DIRECTIONAL ? "0" : "4 2"}
                             markerEnd={rel.type === RELATION_TYPES.DIRECTIONAL ? "url(#arrow)" : ""}
                           />
                           {/* Invisible hit area for easier selection */}
                           <path d={pathD} fill="none" stroke="transparent" strokeWidth={15} />
                         </g>
                       );
                    })}

                    {/* 3. STANDARD OBJECTS (Front) */}
                    {objects.filter(o => o.type !== 'group').map(obj => {
                       const status = getVisibilityStatus(obj.id);
                       if (!status.visible) return null;

                       const isSelected = selection.has(obj.id);

                       return (
                         <g key={obj.id} transform={`translate(${obj.x}, ${obj.y})`}>
                           <rect
                             width={obj.w} height={obj.h}
                             fill={COLORS.stdFill}
                             stroke={isSelected ? COLORS.selection : COLORS.stdStroke}
                             strokeWidth={isSelected ? 2 : 1}
                           />
                           <foreignObject width={obj.w} height={obj.h} className="pointer-events-none">
                              <div className="w-full h-full p-2 flex flex-col items-center justify-center text-center overflow-hidden">
                                  <div className="font-bold text-xs truncate w-full">{obj.name}</div>
                                  {obj.description && (
                                    <div className="text-[10px] text-slate-500 line-clamp-2 leading-tight">{obj.description}</div>
                                  )}
                              </div>
                           </foreignObject>
                         </g>
                       )
                    })}

                    {/* Dragging Connection Line Preview */}
                    {dragState?.type === 'connect' && (
                       <line
                         x1={dragState.start.x} y1={dragState.start.y}
                         x2={dragState.current.x} y2={dragState.current.y}
                         stroke={COLORS.selection}
                         strokeWidth={2}
                         strokeDasharray="4 4"
                       />
                    )}

                    {/* Marquee */}
                    {dragState?.type === 'marquee' && (
                      <rect
                         x={Math.min(dragState.start.x, dragState.current.x)}
                         y={Math.min(dragState.start.y, dragState.current.y)}
                         width={Math.abs(dragState.current.x - dragState.start.x)}
                         height={Math.abs(dragState.current.y - dragState.start.y)}
                         fill={COLORS.selectionBg}
                         stroke={COLORS.selection}
                         strokeWidth={1/view.zoom}
                      />
                    )}

                    {/* Selection Overlay */}
                    {renderSelectionOverlay()}

                    {/* Markers */}
                    <defs>
                      <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                        <path d="M0,0 L0,6 L9,3 z" fill={COLORS.stdStroke} />
                      </marker>
                    </defs>

                  </g>
                </svg>

                {propertyPanel()}

              </div>
            </div>
          );
        }

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>